# 初AHC参加メモ

- 初めてAHC参加するにあたり，思ったことやできなかった/できるようになったことなどを雑に書いていく
- ワンチャンQiitaとかに載せてもいいかも？

## 始めた理由

1. データ構造とアルゴリズムを勉強したかった

- 元々機械学習を研究でやっていて，就活で機械学習エンジニアを目指してた
- 一方，文系学部出身（院から理系）でコンピュータやプログラミングについて学ぶ機会が全くなかったので，データ構造とアルゴリズムに対する理解が全然なかった
- エンジニアになるのにこれはまずいと思い，勉強の機会を探していた

2. Atcoderが強い友達がいた

- Atcoderつよつよの研究室同期がいて，しかもやってる人が研究室にいなくて，やってる人を欲してた
- その友達の影響で2023末にAlgoを始めたが，友達曰くAlgoよりAHCの方が面白いらしい
- 春休み入ったしとりあえずやってみよ（サンプルコード出すだけでレートつくし！）と思い，始めた

## 始める前の印象

- ポジティブ
  - AlgoよりもKaggleっぽくて楽しそう
  - 実務の最適化って感じなのかな？ヒューリスティックって響きかっこいい
  - わからないことあれば（Atcoderのルール内で）友達が教えてくれそうだし，環境充実しててありがたい
- ネガティブ
  - 問題文意味不明そう，長そう...
  - 特に勉強できてなくて，Algoで3回に1回C解けるくらいなのに，AHCなんてできるのか？
  - 就活と研究もあるし，結局やらないで終わるかもな（まあそれでもいいや）

## 始めた時の感想

- 問題について
  - 思ったより問題文わかりやすい，そして短い．もっと意味不明だと思ってたので，この時点で結構モチベが出る
  - 多少わからんことあるけど，まあそれはサンプルコードprintデバッグしたりして確かめればわかりそう
- 実行環境について
  - Webとローカルがあるらしい．ﾗ，ﾗｽﾄ... !?（ここで発狂）
  - PythonとRとC少ししか触ったことないし，データサイエンス的なコーディングしかしたことないし，Rustなんて無理だよ...
  - でも毎回Webに出力貼るのだるいな...やるならローカル動かしたいな
  - とりあえずローカルテスタやってみて，まじで無理そうならやめよ

## 初提出（≠ sample.py）まで

- とりあえずsample.pyをコピペして提出っと...お，AHC初提出&レートつくの確定〜〜やったーー
- このまま次の提出作成入りたいけど，まずは鬼門のローカルテスタだ...いよいよRustだ...
- とりあえずローカルテスタを公式の案内通りに入れて...あれ，なんか普通に動いたぞ？環境構築まじで苦手な俺がRust（でできた何か）を使えているだと...!!?!?!?
  - Rustのインストールだけはこのサイトを参考にして，あとは公式の案内通りにやりました（https://zenn.dev/shogo_wada_pro/articles/365e2710a44f5a）
- おし，sample.py改良するぞー．とりあえず占いは使わず，最小限の改善でスコア上げよ．
  - 左上から掘っていくのはsample.pyから変えず，v(i,j) の累積和が油田の面積と等しくなったらコード終了するようにしよ．そしたら余分に掘るの少なくなって総コスト削減できるやろ！
- （すごく軽微な改善だが）記念すべき自作解法提出！スコアも上がった！AHCたーのし！！！！！

ちなみに，最初は入力される$d_k$個の座標を実際の油田の座標だと勘違いしており，その座標を使って油田が存在するマス目のユニーク数とか計算したりしていた（そんなことはもちろんできない）

このあたりの勘違いは，コード改良して出たエラー原因考えたりしているうちにわかるようになった．手を動かすの大事．

## 占ってみる

- やっぱこのゲームのキモは占いだよな（あたりまえ）
- Algo灰色，二分探索すらも実装したことない俺が占い使えたらカッコよくね？（全然褒められたことではない）
  →とりあえず占いを使ってみよう．以下思いついた順で方針

1. 全部のマス1つずつ占って，1以上のとこだけ掘ればいいのでは？
   →それだと全部掘るよりコストかかるやん．なし
   →ここで，程よく雑に，でも効率よく目星をつけられる占いを行うことが大事と気づく
2. 1行もしくは1列ずつまとめて占って，結果が1以上になった行/列から優先的に掘ろう！
   →採用．ローカルテスタで実行し，ちょっぴりコストが下がる．記念すべき初占い！
   →「行列それぞれ1つずつ占って，片方0のマス目は油田ないのでは？」とふと気づく
3. 行列それぞれ1つずつ占って，両方が1のマス目から優先的に掘る
   →またちょっとコスト下がった．一旦これ提出しよ！占い使って初提出！

## ローカルでの複数入力並列テスト

- 友達からそのうち使いたくなるかもとのことで，以下を紹介してもらう
  - https://zenn.dev/ikoma_3/articles/5c04ab03935f71
- ゆーて使わんやろと思っていたが，一回WAをくらい，原因が単一の入力でしかテストしていなかったことだったので，やってみることにした
- とりあえず動いたものの，Scoreが全部0になっちゃった→友達に助けを求める．
- なんと友達が動くようにコードを書き直してくれた...どうやら，Macに対応してなかったのと，インタラクティブに対応してなかったのが原因みたいでした．友達さまさま...
- テスト結果のcsvをgitで管理して差分見るとか初めてやりました．便利ですね．
  - もし確率的な挙動をするようなコードを書くなら，wandbで管理もしてみたいなと思いました（普段機械学習やっている時にたまに使うので）

## 以降に試したこと&その結果

- 占いを行列単位ではなく，ある大きさの正方形単位でやってみる
  - ちょっとスコア上がった
- ポリオミノの形から存在可能範囲を出して，事前分布を作成
  - 事前分布を雑な占いで更新し，事後分布とする
    - クロス占い
    - 正方形占い
  - 事後確率が高い順に掘っていき，油田数に到達したら終了
- 事後分布を，掘った結果に応じて更新
  - 掘って1以上なら隣接マスを2倍
  - 0なら隣接マスを0.5倍

## 最終的な解法

最終順位：上位30%くらい

解法を一言で表すと：ベイズ更新もどき + オレオレ貪欲法

1. 事前分布の定義
   * ポリオミノの形から事前分布（マスごとの油田数期待値）を定義
3. 占いによる事後分布の導出（事前分布を更新）
   * 一辺の長さdの正方形の範囲を占う（N-d<dの場合，よしなに長方形とする）
   * "占い結果 / 占い範囲のマスの事前分布における総和"を，事前分布の各マスに掛け算し，事後分布とする
     * この時，占いの結果が0の場合のみ0.1をかけるようにする（油田があるのに期待値が0となってしまうマスが出て来るのを防ぐため）
4. 掘りおよび掘りによる事後分布更新
   * 2で導出した事後分布において，期待値が高いマスから掘っていく（貪欲法？）
   * 掘った結果が1以上の場合
     * 掘ったマスの隣接マス（上下左右および斜めのうち，存在するマス）に任意の値を乗算
   * 掘った結果が0の場合
     * 掘ったマスの隣接マス（上下左右および斜めのうち，存在するマス）に任意の値を除算
5. 3を，掘った油田数=入力された油田面積数（$d_k$）の合計，となるまで続ける

## 思いついたこと

- ポイントは，掘る優先順位のリストを生成すること
  - リスト作成にあたり
    - 動的に作るか，静的に作るか
      - 静的：最初に生成してあとは掘るだけ
      - 動的：掘ってリスト更新して...で，リスト生成
    - 占いを使うか否か
      - 占い→掘りか，占い→掘り→占い...か
  - 多分動的に作るのがミソ
    - 探索範囲狭くなると，占う対象狭くなって助かるから
    - 雑に占う→角度高いとこだけ掘る→残り占いであたりつける→最後掘る，が良さそう？
    - 大きいポリオミノ見つけてから残りの範囲を雑に占って，小さいの見つけるのもあり
  - 雑に占う方法
    - 一定の大きさの四角で，期待値が高いところ見つける
    - 0ではない，ではなく，期待値が高い，で選定する
- 大きいポリオミノ見つける
  - ポリオミノの形で占う
    - あるポリオミノの存在範囲は、N-下端+1とN-右端+1の四角形
    - 下端と右端の座標を変数として、2次元多項分布を考える
    - そのポリオミノの形そのままで占った時のvSが大きい位置が、多項分布の値が大きくなる
      →大きい位置を掘って確認する
      - 1こ飛ばしで占って，大きかったとこら辺を掘る
      - 普通に右から掘ってく（最初はこっち）
- ベースライン
  - 大まかな流れ
    - 事前分布の計算
    - 占いによる事後確率更新
    - 掘りによる逐次的な事後確率更新
  - ポイント
    - どこでポリオミノの形を使うか
      - ある程度の時点でこのポリオミノはここだなというのがわかる時もあるはず（特定できたら掘る必要すらないのでコスト削減可能．難しそうだけど）
      - 多分ポリオミノの使い方は二つ
        - ポリオミノの形に従ってなんかする
        - ポリオミノを判定する
        - あるべき使い方は
          - 占い，掘りの結果から現時点でのありうる存在範囲を絞り込む
            ↓
            絞り込みに最も効果的なマスを掘る
            ↓座標を特定して，残り掘らずに申告する
        - でもこれは難しい
          - なんとか部分的に使えない？
        - 

## コンペでできるor上手になったこと

- 目的に合わせたデータ構造の作成
  - （正しいのかわからないが）普段は自分で書かなさそうな辞書やネスト深めのリストを使い，当初は複雑そうで出来なさそうと思っていた処理も書けた
- コマンドラインの扱い
  - 普段あまりターミナルでコマンド実行することがなかったので，各種コマンドやpyファイル上でのコマンドライン引数の扱いを知ることができた
- デバッグ
  - プリントデバッグしかしてないが，前よりデバッグの勘所みたいなものが少し身についた気がする
- git
  - コンペ関係ないが，これに合わせてgitも使い始めたので，gitも（個人で使う範囲で）使えるようになった

## やってみたかったけどできなかったこと

- 占いの効率化
  - Nの大きさや油田の分布状況に応じて，取るべき占いの方法を変える

    - 例えば，1行/列ずつ占う場合と，ある大きさの正方形単位で占っていく場合を比べると，前者はNが大きい場合に，後者はNが小さい場合に効率的？
    - 各行や列に油田はあるけど，その行や列に1,2個しかないことが多い場合は，正方形単位の方が効率的？
- ~~油田が存在するマス目の隣接領域を優先して探索~~
  - ~~（何かしらの方法で）最初に油田が存在するマス目を見つけたとする~~
  - ~~そのマス目の隣接マスを幅優先探索で掘っていく~~
  - - でもこれだとせっかく事前に油田の形状わかってる意味がない...
- 油田の形状に合わせた探索
  - ある油田特有の形を掘り当てられた場合，事前にわかっている油田の形状から掘る位置がわかる
    - 仮に，その油田だけに特有の形でなくても（他の油田も部分的に持っている形状でも），それに従って当たりをつけて掘ったら効率化できそう
    - 掘るたびに，複数ある油田のどれかを判定し．かつ形状を効率的に判定するよう掘っていけば良さそう

      - これ機械学習で言うところのバンディット問題みたいだな？まあ強化学習だからヒューリスティックとは相性良さそうとは思ってたけど，類似性感じられて嬉しいな
- ハイパラ探索
  - ローカルテスタや並列テストコードとoptunaやsklearnのグリッドサーチなどのハイパラ探索ツールをうまく接続できず，人力探索した
- 結果をNやM，$d_k$と合わせて管理
  - コードは作ったが，並列テストが出力したcsvを読み込んで後付けでNとMを足すというもので，使い勝手が悪く結局使わなかった
  - NやMの状況に応じて，いくつかベースラインを作れていればそれを場合分けして使いたかった
- 実験管理
  - csvをgitで管理するのいまいち性に合わなかった
  - ファイル名が日付だと見づらい
  - コミットを毎回書くのがだるい，というか適切な付け方がわからない．毎回，そのファイルの趣旨を書くのではなく，変更文を書くのだと思うが，それだとgithubで最新しか表示されなくてそれのメインの内容がわからない
  - ブランチを切ったほうがいいんだろうなという場面で切っていない．ブランチはまだちゃんと使えてない．
